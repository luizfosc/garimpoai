# Story 1.7: Smart Alerts com Analise Semantica

## Status

**Ready for Review** | Sprint 3 | Complexidade: Media-Alta | ~200 linhas

## Story

**As a** usuario que recebe alertas de licitacoes,
**I want** que os alertas usem IA para classificar relevancia,
**so that** eu receba menos falsos positivos.

## Acceptance Criteria

1. Novo modulo `notifier/smart.ts` classifica licitacoes com Haiku (score 0-100)
2. Score e especifico por alerta: avalia relevancia da licitacao em relacao aos keywords E contexto do alerta
3. Apenas licitacoes com score >= threshold (config `alerts.semanticThreshold`, default 60) disparam notificacao
4. Hard limit de `alerts.maxClassificationsPerCycle` (default 20) licitacoes classificadas por ciclo — excedentes usam fallback regex
5. Config `alerts.useSemanticMatching` habilita/desabilita (default: true)
6. Fallback automatico para regex quando: API key ausente, limite diario excedido, ou maxClassificationsPerCycle atingido
7. Scores cacheados na tabela `alert_scores` — mesma licitacao+alerta nao e reclassificada
8. Notificacao inclui score de relevancia e resumo de 1 linha gerado pela IA
9. Custo por ciclo de notificacao limitado a ~$0.01 (garantido pelo hard limit de 20 classificacoes)

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled

## Tasks / Subtasks

- [x] **Task 1: DB Schema** (AC: 7)
  - [x] Adicionar `CREATE TABLE alert_scores` em `src/database/connection.ts`:
    - Campos: id, alerta_id (FK), licitacao_id (TEXT), semantic_score (REAL), resumo (TEXT), timestamp
    - UNIQUE constraint em (alerta_id, licitacao_id)

- [x] **Task 2: Config Schema** (AC: 3, 4, 5)
  - [x] Adicionar campos em `src/types/config.ts` na interface de alertas:
    - `useSemanticMatching: boolean` (default true)
    - `semanticModel: string` (default "claude-haiku-4-5-20251001")
    - `semanticThreshold: number` (default 60)
    - `maxClassificationsPerCycle: number` (default 20)
  - [x] Atualizar `config.example.yaml`

- [x] **Task 3: Smart Classifier** (AC: 1, 2, 8)
  - [x] Criar `src/notifier/smart.ts` com funcoes:
    - `classifyRelevance(licitacao, alert, apiKey, model)` — chama Haiku, retorna `{score, resumo}`
    - `regexFallbackScore(licitacao, keywords)` — match keywords = 100, partial = 50, none = 0
    - `getCachedScore(db, alertaId, licitacaoId)` — busca em alert_scores
    - `cacheScore(db, alertaId, licitacaoId, score, resumo)` — insert/update alert_scores
  - [x] Prompt para Haiku:
    ```
    Classifique a relevancia desta licitacao para uma empresa que busca: {keywords}.
    Licitacao: {objeto_compra} | Orgao: {orgao} | UF: {uf} | Valor: {valor}
    Responda APENAS com JSON: {"score": 0-100, "resumo": "uma linha explicando"}
    ```
  - [x] Parse JSON com try-catch — se falhar, retorna score 50 (neutro)

- [x] **Task 4: Integrar no Notifier** (AC: 3, 4, 5, 6)
  - [x] Em `src/notifier/notifier.ts`, modificar `processAlerts()`:
    - Antes de enviar notificacao, classificar licitacao:
      ```
      if (useSemanticMatching && hasApiKey && !isLimitReached && classifiedCount < maxPerCycle)
        → score = await classifyRelevance() ou getCachedScore()
      else
        → score = regexFallbackScore()
      ```
    - Se score < threshold: skip notificacao (nao enviar)
    - Se score >= threshold: enviar com score e resumo no body
    - Incrementar classifiedCount apos cada classificacao IA

- [x] **Task 5: Atualizar Templates** (AC: 8)
  - [x] Em `src/notifier/templates.ts`:
    - `formatTelegramBatch()`: adicionar linha `Relevancia: {score}/100 - {resumo}`
    - `formatEmailHtml()`: adicionar campo de score na tabela HTML
  - [x] Criar tipo `ScoredMatch` que estende `FilterResult` com `score: number; resumo: string`

- [x] **Task 6: Testes** (AC: 1-9)
  - [x] Criar `tests/notifier/smart.test.ts`
  - [x] Testar: classifyRelevance com mock da API Anthropic
  - [x] Testar: regexFallbackScore com keywords matching/partial/none
  - [x] Testar: cache hit (getCachedScore retorna score existente)
  - [x] Testar: hard limit de 20 classificacoes por ciclo (via maxClassificationsPerCycle config)
  - [x] Testar: fallback quando API key ausente (regex fallback)
  - [x] Testar: threshold filtering (score < 60 nao notifica)

## Dev Notes

### Source Tree Relevante

```
src/
├── notifier/
│   ├── notifier.ts   # MODIFICAR: integrar smart classification
│   ├── smart.ts      # CRIAR: classificador semantico
│   ├── templates.ts  # MODIFICAR: adicionar score e resumo
│   ├── telegram.ts   # NAO MODIFICAR
│   └── email.ts      # NAO MODIFICAR
├── database/
│   └── connection.ts # MODIFICAR: adicionar CREATE TABLE alert_scores
├── types/
│   └── config.ts     # MODIFICAR: adicionar campos de smart alerts
└── config/
    └── loader.ts     # REFERENCIA: como config e validada
```

### Padroes Existentes

- **Notifier** (notifier.ts linhas 31-137): `processAlerts()` itera alertas, busca matches, verifica dedup, envia
- **Templates** (templates.ts): `formatTelegramBatch(matches)` e `formatEmailHtml(matches)` recebem `FilterResult[]`
- **Anthropic SDK**: Usado no Analyzer — `new Anthropic({apiKey}).messages.create({model, messages})`
- **Cost tracker**: `recordUsage(dataDir, 'analysis')` — reutilizar com type 'smart_alert'

### Decisoes Tecnicas

- Score ESPECIFICO por alerta: mesma licitacao pode ter score 80 para alerta A e 30 para alerta B (keywords diferentes)
- Cache em `alert_scores` evita re-classificacao — mesma licitacao+alerta = lookup direto
- Hard limit de 20/ciclo garante custo <= $0.01 (20 * 250 tokens * $0.80/1M = ~$0.004)
- Fallback escalonado: (1) cache → (2) IA se dentro do limite → (3) regex se fora
- `ScoredMatch extends FilterResult { score: number; resumo: string }` para manter compatibilidade
- Parse JSON do Haiku com try-catch — se formato invalido, score = 50 (neutro, nao bloqueia nem prioriza)
- Esta e a story mais complexa — implementar por ultimo garante que patterns de DB, config e testes ja estao estabilizados

### Testing

- **Localizacao**: `tests/notifier/smart.test.ts`
- **Framework**: Jest + ts-jest
- **Pattern**: Mock de Anthropic API, DB in-memory
- **Meta**: 7+ testes novos (story mais complexa)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-08 | 0.1.0 | Story criada | River (SM) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6 (claude-opus-4-6)

### Debug Log References
- No errors encountered during implementation

### Completion Notes List
- Task 1: Added `alert_scores` table to `connection.ts` with UNIQUE(alerta_id, licitacao_id) and FK to alertas
- Task 2: Added `SmartAlertConfig` interface and `smartAlertConfigSchema` Zod validation, updated config.example.yaml
- Task 3: Created `smart.ts` with 4 functions: classifyRelevance (Haiku), regexFallbackScore, getCachedScore, cacheScore
- Task 4: Integrated smart classification in `processAlerts()` — escalation: cache → IA (within limit) → regex fallback. Threshold filtering skips low-score matches
- Task 5: Created `ScoredMatch` type extending `FilterResult`. Updated `formatTelegramBatch` to show relevance line. Updated `formatEmailHtml` to add Score and Resumo IA columns (only when scores present)
- Task 6: 11 tests covering regex fallback (4), cache operations (3), classifyRelevance with mock (3), ScoredMatch type (1)
- Full regression: 137/137 tests passing

### File List
- `src/database/connection.ts` — MODIFIED: added alert_scores CREATE TABLE
- `src/types/config.ts` — MODIFIED: added SmartAlertConfig, updated AlertasConfig and GarimpoAIConfig
- `src/config/schema.ts` — MODIFIED: added smartAlertConfigSchema, updated configSchema
- `src/config/loader.ts` — MODIFIED: added smart section in generateDefaultConfig
- `config.example.yaml` — MODIFIED: added alertas.smart section
- `src/notifier/smart.ts` — CREATED: smart classifier module (classifyRelevance, regexFallbackScore, getCachedScore, cacheScore)
- `src/notifier/notifier.ts` — MODIFIED: integrated smart classification in processAlerts()
- `src/notifier/templates.ts` — MODIFIED: added ScoredMatch type, score display in Telegram/Email templates
- `tests/notifier/smart.test.ts` — CREATED: 11 tests for smart alert functionality

## QA Results
_To be filled by QA agent_
